<link rel="import" href="../../bower_components/core-animation/core-animation.html">
<link rel="import" href="../../bower_components/core-layout/core-layout.html">
<link rel="import" href="../../bower_components/core-localstorage/core-localstorage.html">
<link rel="import" href="../../bower_components/core-media-query/core-media-query.html">

<link rel="import" href="game-player.html">
<link rel="import" href="game-sprite.html">
<link rel="import" href="socket-io.html">

<link rel="import" href="animate-heighten.html">
<link rel="import" href="animate-pivot.html">
<link rel="import" href="animate-player.html">
<link rel="import" href="animate-pulse.html">
<link rel="import" href="animate-walk.html">

<polymer-element name="game-stage" attributes="binaryMap pathFinding socket world">

  <template>

    <style>

      :host {
        width: 100%;
        z-index: 0;
      }

    </style>

    <socket-io socket="{{ socket }}" devices="{{ devices }}" players="{{ players }}"></socket-io>

    <core-localstorage name="backupPosition" value="{{ backupPosition }}"></core-localstorage>

    <core-media-query query="max-width: 40em" queryMatches="{{ devices.mobile }}"></core-media-query>

    <core-media-query query="(min-width: 40.063em) and (max-width: 64em)" queryMatches="{{ devices.medium }}"></core-media-query>

    <core-media-query query="(min-width: 64.063em) and (max-width: 90em)" queryMatches="{{ devices.large }}"></core-media-query>

    <core-media-query query="(min-width: 90.063em) and (max-width: 120em)" queryMatches="{{ devices.xlarge }}"></core-media-query>

    <core-media-query query="min-width: 120.063em" queryMatches="{{ devices.xxlarge }}"></core-media-query>

    <animate-player id="move" animationLock="{{ animationLock }}" devices="{{ devices }}" path="{{ path }}"></animate-player>

    <game-player class="{{ { medium: devices.medium, large: devices.large, xlarge: devices.xlarge, xxlarge: devices.xxlarge } | tokenList }}" devices="{{ devices }}" style="top: {{ backupPositionY }}; left: {{ backupPositionX }}" id="player"></game-player>

      <template repeat="{{ row, i in world }}">

        <core-layout align="start" justify="start">

          <template repeat="{{ sprite, j in row }}">

            <game-sprite type="{{ sprite }}" class="{{ { medium: devices.medium, large: devices.large, xlarge: devices.xlarge, xxlarge: devices.xxlarge } | tokenList }}" animationLock="{{ animationLock }}" devices="{{ devices }}" matrix="[{{ j }}, {{ i }}]" position="{{ position }}" binaryMap="{{ binaryMap }}"></game-sprite>

          </template>

        </core-layout>

      </template>

  </template>

  <script>

    Polymer('game-stage', {

      created : function () {
        //  Create a lock to define either or not the player is in motion
        this.animationLock = false;
        //  Init default backup position
        this.backupPosition = [0, 0];
        //  Init binary map for pathfinding
        this.binaryMap = [];
        //  Init devices for media queries
        this.devices = {};
        //  Init move object for player motion
        this.path = [0, 0];
        //  Init player position
        this.position = {
          from : [0, 0],
          to   : [0, 0]
        };
        //  Init other players
        this.players = {};
        //  Init world map
        this.world = [];
        //  Get position from localstorage
        this.addEventListener('core-localstorage-load', function(event) {
          if (this.backupPosition !== null) {
            //  Generate left position
            this.backupPositionX = (
              this.backupPosition[0] * this.spriteSize
            ) + 'px';
            //  Generate top position
            this.backupPositionY = (
              this.backupPosition[1] * this.spriteSize
            ) + 'px';
            //  Set backup position as current
            this.position.from = this.backupPosition;
          }
        }.bind(this));
      },

      //  Set observers
      observe : {
        //  Devices
        'devices.mobile'  : 'deviceHasChanged',
        'devices.medium'  : 'deviceHasChanged',
        'devices.large'   : 'deviceHasChanged',
        'devices.xlarge'  : 'deviceHasChanged',
        'devices.xxlarge' : 'deviceHasChanged',
        //  Player position
        'position.to'     : 'playerPositionHasChanged',
        //  World
        'world'           : 'worldHasChanged'
      },

      ready : function () {
        //  Set up player animation
        this.animation = this.$.move.$.animation;
        this.animation.target = this.$.player;
        this.animation.fill = 'forwards';
      },

      //  Device has changed
      deviceHasChanged : function () {
        if (this.devices.mobile)  { this.spriteSize = 60; }
        if (this.devices.medium)  { this.spriteSize = 75; }
        if (this.devices.large)   { this.spriteSize = 90; }
        if (this.devices.xlarge)  { this.spriteSize = 105; }
        if (this.devices.xxlarge) { this.spriteSize = 120; }
      },

      //  Player position has changed
      playerPositionHasChanged : function () {
        //  Backup the grid as its value is modified after path-finding
        var gridBackup = this.grid.clone();
        //  Then use the finder to generate an array of moves
        this.path = this.finder.findPath(
          this.position.from[0],
          this.position.from[1],
          this.position.to[0],
          this.position.to[1],
          this.grid
        );
        //  Restore original grid
        this.grid = gridBackup;
        //  Set updated position accordingly
        this.position.from = this.position.to;
        //  Create a backup in localstorage
        this.backupPosition = this.position.to;
        this.backupPositionX = 0;
        this.backupPositionY = 0;
      },

      worldHasChanged : function () {
        //  Reuse pathfinding library object's name
        var PF = this.pathFinding;
        //  Create a grid & define heuristic
        this.grid = new PF.Grid(20, 20, this.binaryMap);
        this.finder = new PF.AStarFinder({heuristic: PF.Heuristic.chebyshev});
      }

    });

  </script>

</polymer-element>
