<link rel="import" href="../../bower_components/polymer-media-query/polymer-media-query.html">

<link rel="import" href="../../bower_components/polymer-flex-layout/polymer-flex-layout.html">

<link rel="import" href="../../bower_components/polymer-animation/polymer-animation.html">

<link rel="import" href="game-sprite.html">

<link rel="import" href="game-player.html">

<link rel="import" href="animate-pivot.html">

<polymer-element name="game-stage">

  <template>

    <style>

      :host {
        width: 100%;
        background: rgba(0,0,0,1);
        z-index: 0;
      }

    </style>

    <polymer-media-query query="max-width: 40rem" queryMatches="{{ devices.mobile }}"></polymer-media-query>

    <polymer-media-query query="(min-width: 40.063rem) and (max-width: 64rem)" queryMatches="{{ devices.medium }}"></polymer-media-query>

    <polymer-media-query query="(min-width: 64.063rem) and (max-width: 90rem)" queryMatches="{{ devices.large }}"></polymer-media-query>

    <polymer-media-query query="(min-width: 90.063rem) and (max-width: 120rem)" queryMatches="{{ devices.xlarge }}"></polymer-media-query>

    <polymer-media-query query="min-width: 120.063rem" queryMatches="{{ devices.xxlarge }}"></polymer-media-query>

    <game-player class="{{ { medium: devices.medium, large: devices.large, xlarge: devices.xlarge, xxlarge: devices.xxlarge } | tokenList }}" devices="{{ devices }}" position="{{ position }}"></game-player>

      <template repeat="{{ row, i in world }}">

        <polymer-flex-layout isContainer align="start" justify="start">

          <template repeat="{{ sprite, j in row }}">

            <game-sprite type="{{ sprite }}" class="{{ { medium: devices.medium, large: devices.large, xlarge: devices.xlarge, xxlarge: devices.xxlarge } | tokenList }}" devices="{{ devices }}" matrix="[{{ i }}, {{ j }}]" position="{{ position }}"></game-sprite>

          </template>

        </polymer-flex-layout>

      </template>

  </template>

  <script>

    Polymer('game-stage', {
        position : [0, 0],
        devices : {},
        world : [
          [0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 1, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 3, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 3, 0, 3, 1, 1, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        ],
        crossableSprites : [0, 3],
        isCrossable : function (type) {
          return this.crossableSprites.indexOf(type) !== -1 ? true : false;
        },
        toBinaryMatrix : function (world) {
          var binaryWorld = [],
              toBinary = function (value) {
                return this.isCrossable(value) ? 0 : 1;
              }.bind(this);
          world.forEach(function (row) {
            binaryWorld.push(row.map(toBinary));
          });
          return binaryWorld;
        },
        ready : function () {
          console.log(this.position);
          var binaryWorld = this.toBinaryMatrix(this.world);
          this.grid = new PF.Grid(20, 20, binaryWorld);
          this.finder = new PF.AStarFinder();
        },
        positionChanged : function () {
          console.log(this.position);
          //  Backup the grid as its value is changed after path-finding
          var gridBackup = this.grid.clone(),
              path = this.finder.findPath(0, 0, 8, 2, this.grid);
          this.grid = gridBackup;
          console.log(path);
        }
    });

  </script>

</polymer-element>