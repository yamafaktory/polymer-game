<link rel="import" href="../../bower_components/polymer-media-query/polymer-media-query.html">

<link rel="import" href="../../bower_components/polymer-flex-layout/polymer-flex-layout.html">

<link rel="import" href="../../bower_components/polymer-animation/polymer-animation.html">

<link rel="import" href="game-sprite.html">

<link rel="import" href="game-player.html">

<link rel="import" href="animate-pivot.html">

<link rel="import" href="animate-player.html">

<polymer-element name="game-stage">

  <template>

    <style>

      :host {
        width: 100%;
        background: rgba(0,0,0,1);
        z-index: 0;
      }

    </style>

    <polymer-media-query query="max-width: 40rem" queryMatches="{{ devices.mobile }}"></polymer-media-query>

    <polymer-media-query query="(min-width: 40.063rem) and (max-width: 64rem)" queryMatches="{{ devices.medium }}"></polymer-media-query>

    <polymer-media-query query="(min-width: 64.063rem) and (max-width: 90rem)" queryMatches="{{ devices.large }}"></polymer-media-query>

    <polymer-media-query query="(min-width: 90.063rem) and (max-width: 120rem)" queryMatches="{{ devices.xlarge }}"></polymer-media-query>

    <polymer-media-query query="min-width: 120.063rem" queryMatches="{{ devices.xxlarge }}"></polymer-media-query>

    <animate-player id="animate" path="{{ move.path }}"></animate-player>

    <game-player class="{{ { medium: devices.medium, large: devices.large, xlarge: devices.xlarge, xxlarge: devices.xxlarge } | tokenList }}" devices="{{ devices }}" position="{{ position }}" id="player"></game-player>

      <template repeat="{{ row, i in world }}">

        <polymer-flex-layout isContainer align="start" justify="start">

          <template repeat="{{ sprite, j in row }}">

            <game-sprite type="{{ sprite }}" class="{{ { medium: devices.medium, large: devices.large, xlarge: devices.xlarge, xxlarge: devices.xxlarge } | tokenList }}" devices="{{ devices }}" matrix="[{{ i }}, {{ j }}]" position="{{ position }}"></game-sprite>

          </template>

        </polymer-flex-layout>

      </template>

  </template>

  <script>

    Polymer('game-stage', {
      // Init player position
      position : {
        from : [0, 0],
        to   : [0, 0]
      },
      //  Init devices for media queries
      devices : {},
      //  Init move object for player motion
      move : {},
      //  The world map
      world : [
        [0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 1, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 3, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 3, 0, 3, 1, 1, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
      ],
      //  Define which sprites are crossable
      crossableSprites : [0, 3],
      //  Method to test if a sprite is crossable
      isCrossable : function (type) {
        return this.crossableSprites.indexOf(type) !== -1 ? true : false;
      },
      //  Method to convert the map as binary values
      toBinaryMatrix : function (world) {
        var binaryWorld = [],
            toBinary = function (value) {
              return this.isCrossable(value) ? 0 : 1;
            }.bind(this);
        world.forEach(function (row) {
          binaryWorld.push(row.map(toBinary));
        });
        return binaryWorld;
      },
      //  Polymer element is ready
      ready : function () {
        var binaryWorld = this.toBinaryMatrix(this.world);
        this.grid = new PF.Grid(20, 20, binaryWorld);
        this.finder = new PF.AStarFinder();
      },
      //  Launch player animation
      movePlayer : function () {
        var animation = this.$.animate.$.animation;
        console.log(animation);
        animation.target = this.$.player;
        animation.play();
      },
      //  Set observers
      observe: {
        'position.to': 'playerPositionHasChanged'
      },
      //  Player position has changed
      playerPositionHasChanged : function () {
        //  Backup the grid as its value is modified after path-finding
        //  Then use the finder to generate an array of moves
        var gridBackup = this.grid.clone(),
            path = this.finder.findPath(
              this.position.from[0],
              this.position.from[1],
              this.position.to[0],
              this.position.to[1],
              this.grid
            ),
            //  Generate an iterative path for player animation
            iterativePath = function () {
              var newPath = [[0, 0]];
              //  Start at 1 as 0 is current position
              for (var i = 1; i < path.length; ++i) {
                //  Test x axis first
                if (path[i][0] === path[i-1][0]) {
                  if (path[i][1] > path[i-1][1]) {
                    // Greater y value
                    newPath.push([0, 1]);
                  } else {
                    // Lower y value
                    newPath.push([0, -1]);
                  }
                } else {
                  if (path[i][0] > path[i-1][0]) {
                    // Greater x value
                    newPath.push([1, 0]);
                  } else {
                    // Lower x value
                    newPath.push([-1, 0]);
                  }
                }
              }
              return newPath;
            };
        //  Restore original grid
        this.grid = gridBackup;
        //  Player motion
        //  First send the iterative path to the animation element
        this.move.path = iterativePath(path);
        console.log(this.move.path);
        //  Then move the player
        this.movePlayer();
        //  Finally set update position accordingly
        this.position.from = this.position.to;
      }
    });

  </script>

</polymer-element>